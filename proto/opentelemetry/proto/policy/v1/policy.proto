syntax = "proto3";

package opentelemetry.proto.policy.v1;

import "google/api/annotations.proto";
import "opentelemetry/proto/common/v1/common.proto";

option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/policy/v1";
option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.policy.v1";

// =============================================================================
// Core Policy Types
// =============================================================================

// PolicyType identifies the specific use case for a policy.
// Policies of the same type can be merged; different types cannot.
enum PolicyType {
  POLICY_TYPE_UNSPECIFIED = 0;
  POLICY_TYPE_LOG_FILTER = 1; // Define how logs are filtered (keep/drop)
  POLICY_TYPE_REDACTION = 2; // Define data needing redaction/removal
}

// TelemetryType specifies what kind of telemetry data a policy applies to.
enum TelemetryType {
  TELEMETRY_TYPE_UNSPECIFIED = 0;
  TELEMETRY_TYPE_LOGS = 1;
}

// =============================================================================
// Matching
// =============================================================================

// MatchType specifies the category of telemetry field to match against.
// Each match type is only valid for certain TelemetryTypes:
//   - RESOURCE, RESOURCE_ATTRIBUTE, SCOPE, SCOPE_ATTRIBUTE: all telemetry types
//   - LOG_BODY, LOG_SEVERITY, LOG_ATTRIBUTE: TELEMETRY_TYPE_LOGS only
//   - METRIC_NAME, METRIC_ATTRIBUTE: TELEMETRY_TYPE_METRICS only (future)
//   - SPAN_NAME, SPAN_KIND, SPAN_STATUS, SPAN_ATTRIBUTE: TELEMETRY_TYPE_TRACES only (future)
enum MatchType {
  MATCH_TYPE_UNSPECIFIED = 0;

  // Resource-level matching (applies to all telemetry types)
  MATCH_TYPE_RESOURCE_ATTRIBUTE = 1; // Match resource attribute by key (e.g., "service.name")

  // Scope-level matching (applies to all telemetry types)
  MATCH_TYPE_SCOPE_NAME = 2; // Match instrumentation scope name
  MATCH_TYPE_SCOPE_VERSION = 3; // Match instrumentation scope version
  MATCH_TYPE_SCOPE_ATTRIBUTE = 4; // Match scope attribute by key

  // Log-specific matching (requires TELEMETRY_TYPE_LOGS)
  MATCH_TYPE_LOG_BODY = 10; // Match log body content
  MATCH_TYPE_LOG_SEVERITY_TEXT = 11; // Match severity text (e.g., "ERROR", "WARN")
  MATCH_TYPE_LOG_SEVERITY_NUMBER = 12; // Match severity number (1-24)
  MATCH_TYPE_LOG_ATTRIBUTE = 13; // Match log record attribute by key

  // Metric-specific matching (requires TELEMETRY_TYPE_METRICS - future)
  MATCH_TYPE_METRIC_NAME = 20; // Match metric name
  MATCH_TYPE_METRIC_ATTRIBUTE = 21; // Match metric data point attribute by key

  // Trace-specific matching (requires TELEMETRY_TYPE_TRACES - future)
  MATCH_TYPE_SPAN_NAME = 30; // Match span name
  MATCH_TYPE_SPAN_KIND = 31; // Match span kind (CLIENT, SERVER, etc.)
  MATCH_TYPE_SPAN_STATUS = 32; // Match span status code (OK, ERROR, UNSET)
  MATCH_TYPE_SPAN_ATTRIBUTE = 33; // Match span attribute by key
}

// Matcher provides a unified way to match against telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
// - Multiple matchers are ANDed together: all matchers must match for the
//   overall match to succeed.
// - The match_type must be valid for the policy's telemetry_types. For example,
//   MATCH_TYPE_LOG_BODY is only valid when TELEMETRY_TYPE_LOGS is in the
//   policy's telemetry_types list.
// - The list of matchers should uniquely identify a specific pattern of telemetry
//   for that policy. Matchers should NOT be used as a catch-all; they should be
//   specific enough to target the intended telemetry precisely.
//
// The regex uses RE2 syntax for consistency across implementations.
//
// Examples:
//   Match logs from payment service with ERROR severity:
//     matchers: [
//       {match_type: RESOURCE_ATTRIBUTE, key: "service.name", regex: "^payment-service$"},
//       {match_type: LOG_SEVERITY_TEXT, regex: "^ERROR$"}
//     ]
//
//   Match logs containing PII in body from any service in prod:
//     matchers: [
//       {match_type: RESOURCE_ATTRIBUTE, key: "deployment.environment", regex: "^prod.*"},
//       {match_type: LOG_BODY, regex: "\\b[0-9]{3}-[0-9]{2}-[0-9]{4}\\b"}
//     ]
message Matcher {
  // The type of field to match against. Determines which telemetry field
  // is selected for matching.
  MatchType match_type = 1;

  // Key for attribute-based match types (RESOURCE_ATTRIBUTE, SCOPE_ATTRIBUTE,
  // LOG_ATTRIBUTE, METRIC_ATTRIBUTE, SPAN_ATTRIBUTE).
  // For example: "service.name", "http.method", "user.id"
  // Ignored for non-attribute match types.
  string key = 2;

  // Regular expression pattern to match the field value against.
  // Uses RE2 syntax. An empty regex matches any value (existence check).
  string regex = 3;

  // If true, inverts the match (matches when regex does NOT match)
  bool negate = 4;
}

// =============================================================================
// Policy Type Configurations
// =============================================================================

// FilterAction specifies what to do with matched logs.
enum FilterAction {
  FILTER_ACTION_UNSPECIFIED = 0;
  FILTER_ACTION_KEEP = 1; // Keep logs that match
  FILTER_ACTION_DROP = 2; // Drop logs that match
}

// FilterConfig defines configuration for LOG_FILTER policies.
// Matches logs based on conditions and keeps or drops them.
message FilterConfig {
  // Matchers to identify which logs this filter applies to (AND logic)
  repeated Matcher matchers = 1;

  // Action to take on matched logs
  FilterAction action = 2;
}

// RedactionRule defines a single find/replace redaction operation.
// Similar to sed's s/pattern/replacement/ syntax.
message RedactionRule {
  // JSONPath to the field to apply redaction to.
  // Example: "$.body", "$.attributes.user.email", "$.attributes.*"
  string path = 1;

  // Regular expression pattern to find (RE2 syntax).
  // Example: "[0-9]{3}-[0-9]{2}-[0-9]{4}" for SSN
  // Example: "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}" for email
  string pattern = 2;

  // Replacement string. Supports capture group references ($1, $2, etc.)
  // Example: "[REDACTED]"
  // Example: "$1-****-$3" to partially mask
  // Default: "[REDACTED]"
  string replacement = 3;
}

// RedactionConfig defines configuration for REDACTION policies.
// Applies sed-like find/replace redaction rules to matched logs.
message RedactionConfig {
  // Matchers to identify which logs to apply redaction to (AND logic)
  // If empty, redaction applies to all logs
  repeated Matcher matchers = 1;

  // Redaction rules to apply (applied in order)
  repeated RedactionRule rules = 2;
}

// =============================================================================
// Policy Definition
// =============================================================================

// Policy represents a complete telemetry policy definition.
// Policies are designed to be:
// - Typed: Self-identifies its type; same types can merge
// - Implementation Agnostic: Works in SDK, Collector, or any component
// - Standalone: No need to understand pipeline configuration
// - Dynamic: Can be updated post-instantiation
// - Idempotent: Safe to apply to multiple components
// - Fail-Open: Does not interfere with telemetry on failure
//
// Merge Strategy: Policies of the same type are merged using priority.
// Higher priority values take precedence when rules conflict.
message Policy {
  // Unique identifier for this policy
  string id = 1;

  // Human-readable name
  string name = 2;

  // Optional description
  string description = 3;

  // The type of policy (must match the config oneof field used)
  PolicyType policy_type = 4;

  // Telemetry types this policy applies to
  repeated TelemetryType telemetry_types = 5;

  // Priority for merge conflict resolution (higher = more important)
  int32 priority = 6;

  // Policy configuration based on policy_type
  oneof config {
    FilterConfig filter = 7;
    RedactionConfig redaction = 8;
  }

  // Whether this policy is enabled
  bool enabled = 9;

  // Metadata labels for organization and filtering
  repeated opentelemetry.proto.common.v1.KeyValue labels = 10;

  // Timestamp when this policy was created (Unix epoch nanoseconds)
  fixed64 created_at_unix_nano = 11;

  // Timestamp when this policy was last modified (Unix epoch nanoseconds)
  fixed64 modified_at_unix_nano = 12;
}

// =============================================================================
// Policy Collections and Management
// =============================================================================

// PolicySet represents a collection of policies from a single source/provider.
message PolicySet {
  // Unique identifier for this policy set
  string id = 1;

  // Human-readable name
  string name = 2;

  // The policies in this set
  repeated Policy policies = 3;

  // Version/hash of the entire set (for change detection)
  string version = 4;

  // Source identifier (which provider supplied this)
  string source = 5;

  // Timestamp of this policy set (Unix epoch nanoseconds)
  fixed64 timestamp_unix_nano = 6;
}

// =============================================================================
// Sync Protocol (for Policy Providers)
// =============================================================================

// ClientMetadata contains information about the client requesting policies.
message ClientMetadata {
  // Unique identifier for the client instance
  string client_id = 1;

  // Version of the client software
  string client_version = 2;

  // Identifier for the workspace/tenant
  string workspace_id = 3;

  // Last sync timestamp (Unix epoch nanoseconds)
  fixed64 last_sync_timestamp_unix_nano = 4;

  // Policy types this client supports/wants
  repeated PolicyType supported_policy_types = 5;

  // Telemetry types this client handles
  repeated TelemetryType supported_telemetry_types = 6;

  // Additional metadata labels
  repeated opentelemetry.proto.common.v1.KeyValue labels = 7;

  // Resource attributes describing this client's identity
  repeated opentelemetry.proto.common.v1.KeyValue resource_attributes = 8;
}

// SyncRequest is sent by clients to request policy updates.
message SyncRequest {
  // Client identification and capabilities
  ClientMetadata client_metadata = 1;

  // Request full sync (ignore last_policy_version)
  bool full_sync = 2;
}

// SyncResponse contains policy updates for the client.
message SyncResponse {
  // The complete policy set to apply
  PolicySet policy_set = 1;

  // Timestamp of this sync (Unix epoch nanoseconds)
  fixed64 sync_timestamp_unix_nano = 2;

  // Suggested interval before next sync (in seconds)
  uint32 recommended_sync_interval_seconds = 3;

  // Whether this is a full replacement or incremental update
  bool is_full_sync = 4;

  // Error message if sync failed
  string error_message = 5;
}

// =============================================================================
// Policy Provider Service (optional - for gRPC providers)
// =============================================================================

// PolicyService defines the gRPC service for policy providers.
service PolicyService {
  // Sync policies with the provider
  rpc Sync(SyncRequest) returns (SyncResponse) {
    option (google.api.http) = {
      post: "/v1/policy/sync"
      body: "*"
    };
  }
}
