syntax = "proto3";

package opentelemetry.proto.policy.v1;

import "google/api/annotations.proto";
import "opentelemetry/proto/common/v1/common.proto";

option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/policy/v1";
option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.policy.v1";

// =============================================================================
// Matching
// =============================================================================

// LogMatcher provides a way to match against log telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
// - Multiple matchers are ANDed together: all matchers must match for the
//   overall match to succeed.
// - The list of matchers should uniquely identify a specific pattern of telemetry
//   for that policy. Matchers should NOT be used as a catch-all; they should be
//   specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
//
// Examples:
//   Match logs from payment service with ERROR severity:
//     matchers: [
//       {resource_attribute: {key: "service.name", regex: "^payment-service$"}},
//       {log_severity_text: {regex: "^ERROR$"}}
//     ]
//
//   Match logs containing PII in body from any service in prod:
//     matchers: [
//       {resource_attribute: {key: "deployment.environment", regex: "^prod.*"}},
//       {log_body: {regex: "\\b[0-9]{3}-[0-9]{2}-[0-9]{4}\\b"}}
//     ]
message LogMatcher {
  // If true, inverts the match (matches when the field does NOT match)
  bool negate = 1;

  // The field to match against. Exactly one must be set.
  oneof match {
    // Resource-level matching
    ResourceSchemaUrlMatch resource_schema_url = 10;
    ResourceAttributeMatch resource_attribute = 11;

    // Scope-level matching
    ScopeSchemaUrlMatch scope_schema_url = 12;
    ScopeNameMatch scope_name = 13;
    ScopeVersionMatch scope_version = 14;
    ScopeAttributeMatch scope_attribute = 15;

    // Log-specific matching
    LogBodyMatch log_body = 20;
    LogSeverityTextMatch log_severity_text = 21;
    LogSeverityNumberMatch log_severity_number = 22;
    LogAttributeMatch log_attribute = 23;
  }
}

// =============================================================================
// Resource and Scope Matchers (apply to all telemetry types)
// =============================================================================

// ResourceSchemaUrlMatch matches against the resource schema URL.
message ResourceSchemaUrlMatch {
  // Regex pattern to match the resource schema URL.
  string regex = 1;
}

// ResourceAttributeMatch matches against a resource attribute by key.
message ResourceAttributeMatch {
  // The attribute key to match (e.g., "service.name", "deployment.environment")
  string key = 1;

  // Regex pattern to match the attribute value. Empty matches any value (existence check).
  string regex = 2;
}

// ScopeNameMatch matches against the instrumentation scope name.
message ScopeNameMatch {
  // Regex pattern to match the scope name.
  string regex = 1;
}

// ScopeVersionMatch matches against the instrumentation scope version.
message ScopeVersionMatch {
  // Regex pattern to match the scope version.
  string regex = 1;
}

// ScopeAttributeMatch matches against a scope attribute by key.
message ScopeAttributeMatch {
  // The attribute key to match.
  string key = 1;

  // Regex pattern to match the attribute value. Empty matches any value (existence check).
  string regex = 2;
}

// ScopeSchemaUrlMatch matches against the instrumentation scope schema URL.
message ScopeSchemaUrlMatch {
  // Regex pattern to match the scope schema URL.
  string regex = 1;
}

// =============================================================================
// Log Matchers
// =============================================================================

// LogBodyMatch matches against the log record body.
message LogBodyMatch {
  // Regex pattern to match the log body content.
  string regex = 1;
}

// LogSeverityTextMatch matches against the log severity text.
message LogSeverityTextMatch {
  // Regex pattern to match the severity text (e.g., "ERROR", "WARN", "INFO").
  string regex = 1;
}

// LogSeverityNumberMatch matches against the log severity number.
message LogSeverityNumberMatch {
  // Minimum severity number (inclusive). Range: 1-24.
  int32 min = 1;

  // Maximum severity number (inclusive). Range: 1-24.
  // If 0, only min is used for exact match.
  int32 max = 2;
}

// LogAttributeMatch matches against a log record attribute by key.
message LogAttributeMatch {
  // The attribute key to match (e.g., "user.id", "http.method").
  string key = 1;

  // Regex pattern to match the attribute value. Empty matches any value (existence check).
  string regex = 2;
}

// =============================================================================
// Metric Matchers (future)
// =============================================================================

// // MetricNameMatch matches against the metric name.
// message MetricNameMatch {
//   // Regex pattern to match the metric name.
//   string regex = 1;
// }

// // MetricAttributeMatch matches against a metric data point attribute by key.
// message MetricAttributeMatch {
//   // The attribute key to match.
//   string key = 1;

//   // Regex pattern to match the attribute value. Empty matches any value (existence check).
//   string regex = 2;
// }

// =============================================================================
// Span Matchers (future)
// =============================================================================

// // SpanNameMatch matches against the span name.
// message SpanNameMatch {
//   // Regex pattern to match the span name.
//   string regex = 1;
// }

// // SpanKindMatch matches against the span kind.
// message SpanKindMatch {
//   // The span kind to match.
//   // See opentelemetry.proto.trace.v1.Span.SpanKind for valid values.
//   opentelemetry.proto.trace.v1.Span.SpanKind kind = 1;
// }

// // SpanStatusMatch matches against the span status code.
// // Uses opentelemetry.proto.trace.v1.Status.StatusCode from the trace proto.
// message SpanStatusMatch {
//   // The status code to match.
//   // See opentelemetry.proto.trace.v1.Status.StatusCode for valid values.
//   opentelemetry.proto.trace.v1.Status.StatusCode code = 1;
// }

// // SpanAttributeMatch matches against a span attribute by key.
// message SpanAttributeMatch {
//   // The attribute key to match.
//   string key = 1;

//   // Regex pattern to match the attribute value. Empty matches any value (existence check).
//   string regex = 2;
// }

// =============================================================================
// Policy Type Configurations
// =============================================================================

// FilterAction specifies what to do with matched logs.
enum FilterAction {
  FILTER_ACTION_UNSPECIFIED = 0;
  FILTER_ACTION_KEEP = 1;
  FILTER_ACTION_DROP = 2;
}

// LogFilterConfig defines configuration for log filter policies.
// Matches logs based on conditions and keeps or drops them.
message LogFilterConfig {
  // Matchers to identify which logs this filter applies to (AND logic)
  repeated LogMatcher matchers = 1;

  // Action to take on matched logs
  FilterAction action = 2;
}

// =============================================================================
// Policy Definition
// =============================================================================

// Policy represents a complete telemetry policy definition.
// Policies are designed to be:
// - Implementation Agnostic: Works in SDK, Collector, or any component
// - Standalone: No need to understand pipeline configuration
// - Dynamic: Can be updated post-instantiation
// - Idempotent: Safe to apply to multiple components
// - Fail-Open: Does not interfere with telemetry on failure
//
// Merge Strategy: Policies are merged using priority.
// Higher priority values take precedence when rules conflict.
message Policy {
  // Unique identifier for this policy
  string id = 1;

  // Human-readable name
  string name = 2;

  // Optional description
  string description = 3;

  // Priority for merge conflict resolution (higher = more important)
  int32 priority = 4;

  // Whether this policy is enabled
  bool enabled = 5;

  // Timestamp when this policy was created (Unix epoch nanoseconds)
  fixed64 created_at_unix_nano = 6;

  // Timestamp when this policy was last modified (Unix epoch nanoseconds)
  fixed64 modified_at_unix_nano = 7;

  // These labels can be used by an implementation to intelligently
  // compile and route telemetry.
  // Labels MAY contain metadata about the telemetry types this policy applies to.
  // The key could be telemetry.types="type1,type2,type3"
  repeated opentelemetry.proto.common.v1.KeyValue labels = 8;

  // Policy configuration. Exactly one must be set.
  oneof config {
    LogFilterConfig log_filter = 9;
  }
}

// =============================================================================
// Core Policy Types
// =============================================================================

// PolicyType identifies the specific use case for a policy.
// Policies of the same type can be merged; different types cannot.
enum PolicyType {
  POLICY_TYPE_UNSPECIFIED = 0;
  POLICY_TYPE_LOG_FILTER = 1; // Define how logs are filtered (keep/drop)
}

// =============================================================================
// Sync Protocol (for Policy Providers)
// =============================================================================

// ClientMetadata contains information about the client requesting policies.
message ClientMetadata {
  // Policy types this client supports/wants
  repeated PolicyType supported_policy_types = 1;

  // Additional metadata labels
  // NOTE FOR TERO:
  // * workspace.id is required for usage.
  repeated opentelemetry.proto.common.v1.KeyValue labels = 2;

  // Resource attributes describing this client's identity
  // REQUIRED:
  // * service.instance.id
  // * service.name
  // * service.namespace
  // * service.version
  repeated opentelemetry.proto.common.v1.KeyValue resource_attributes = 3;
}

// PolicySyncStatus reports the status of an individual policy during sync.
// Used to communicate policy execution metrics and errors back to the provider.
message PolicySyncStatus {
  // The policy ID this status refers to.
  string id = 1;

  // Number of times this policy matched telemetry since the last sync.
  int64 hits = 2;

  // Number of times this policy was evaluated but did not match.
  int64 misses = 3;

  // Error messages encountered while applying this policy.
  repeated string errors = 4;
}

// SyncRequest is sent by clients to request policy updates.
message SyncRequest {
  // Client identification and capabilities
  ClientMetadata client_metadata = 1;

  // Request full sync (ignore policy_statuses)
  bool full_sync = 2;

  // Last sync timestamp (Unix epoch nanoseconds)
  fixed64 last_sync_timestamp_unix_nano = 3;

  // The hash of the policy list as last received by the client.
  string last_successful_hash = 4;

  // Status of individual policies within this set.
  repeated PolicySyncStatus policy_statuses = 5;
}

enum SyncType {
  SYNC_TYPE_UNSPECIFIED = 0;
  SYNC_TYPE_FULL = 1;

  // These are future fields for when we may want to support diffing.
  // SYNC_TYPE_ADD = 2;
  // SYNC_TYPE_REMOVE = 3;
  // SYNC_TYPE_UPDATE = 4;
}

// SyncResponse contains policy updates for the client.
message SyncResponse {
  // The policies to sync
  repeated Policy policies = 1;

  // Hash of the entire list of policies (for change detection)
  string hash = 2;

  // Timestamp of this sync (Unix epoch nanoseconds)
  fixed64 sync_timestamp_unix_nano = 3;

  // Suggested interval before next sync (in seconds)
  uint32 recommended_sync_interval_seconds = 4;

  // Whether this is a full replacement or incremental update
  SyncType sync_type = 5;

  // Error message if sync failed
  string error_message = 6;
}

// =============================================================================
// Policy Provider Service (optional - for gRPC providers)
// =============================================================================

// PolicyService defines the gRPC service for policy providers.
service PolicyService {
  // Sync policies with the provider
  rpc Sync(SyncRequest) returns (SyncResponse) {
    option (google.api.http) = {
      post: "/v1/policy/sync"
      body: "*"
    };
  }
}
