syntax = "proto3";

package tero.policy.v1;

import "tero/policy/v1/shared.proto";

option go_package = "github.com/usetero/policy/gen/go/tero/policy/v1";

// =============================================================================
// Trace Target
// =============================================================================

// TraceTarget defines matching and sampling actions for traces/spans.
message TraceTarget {
  // Matchers to identify which spans this policy applies to (AND logic)
  repeated TraceMatcher match = 1;

  // The keep field controls whether matching spans are sampled.
  // For traces, this uses probabilistic sampling with tracestate support.
  TraceSamplingConfig keep = 2;
}

// =============================================================================
// Trace Field Selection
// =============================================================================

// TraceField identifies simple span fields (non-keyed).
enum TraceField {
  TRACE_FIELD_UNSPECIFIED = 0;

  // Span fields
  TRACE_FIELD_NAME = 1;
  TRACE_FIELD_TRACE_ID = 2;
  TRACE_FIELD_SPAN_ID = 3;
  TRACE_FIELD_PARENT_SPAN_ID = 4;
  TRACE_FIELD_TRACE_STATE = 5;

  // Schema URLs
  TRACE_FIELD_RESOURCE_SCHEMA_URL = 10;
  TRACE_FIELD_SCOPE_SCHEMA_URL = 11;

  // Scope fields (InstrumentationScope)
  TRACE_FIELD_SCOPE_NAME = 12;
  TRACE_FIELD_SCOPE_VERSION = 13;
}

// SpanKind identifies the type of span for matching.
// Mirrors opentelemetry.proto.trace.v1.Span.SpanKind.
enum SpanKind {
  SPAN_KIND_UNSPECIFIED = 0;
  SPAN_KIND_INTERNAL = 1;
  SPAN_KIND_SERVER = 2;
  SPAN_KIND_CLIENT = 3;
  SPAN_KIND_PRODUCER = 4;
  SPAN_KIND_CONSUMER = 5;
}

// SpanStatusCode identifies the span status for matching.
// Mirrors opentelemetry.proto.trace.v1.Status.StatusCode.
enum SpanStatusCode {
  SPAN_STATUS_CODE_UNSPECIFIED = 0;
  SPAN_STATUS_CODE_OK = 1;
  SPAN_STATUS_CODE_ERROR = 2;
}

// =============================================================================
// Trace Matching
// =============================================================================

// TraceMatcher provides a way to match against trace/span telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
// - Multiple matchers are ANDed together: all matchers must match for the
//   overall match to succeed.
// - The list of matchers should uniquely identify a specific pattern of telemetry
//   for that policy. Matchers should NOT be used as a catch-all; they should be
//   specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
message TraceMatcher {
  // FIELD SELECTION
  // The field to match against. Exactly one must be set.
  oneof field {
    // Simple fields (name, trace_id, span_id, etc.)
    TraceField trace_field = 1;

    // Span attribute by key or path
    AttributePath span_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;

    // Span kind matcher
    SpanKind span_kind = 5;

    // Span status code matcher
    SpanStatusCode span_status = 6;

    // Event name matcher (matches if span contains an event with this name)
    string event_name = 7;

    // Event attribute matcher (matches if span contains an event with this attribute)
    AttributePath event_attribute = 8;

    // Link trace ID matcher (matches if span has a link to this trace)
    string link_trace_id = 9;
  }

  // Match type. Exactly one must be set.
  // Note: For span_kind and span_status fields, only exists is valid (equality is implicit).
  oneof match {
    // Exact string match
    string exact = 10;

    // Regular expression match
    string regex = 11;

    // Field existence check
    bool exists = 12;

    // Literal prefix match
    string starts_with = 13;

    // Literal suffix match
    string ends_with = 14;

    // Literal substring match
    string contains = 15;
  }

  // If true, inverts the match result
  bool negate = 20;

  // If true, applies case-insensitive matching to all match types
  bool case_insensitive = 21;
}

// =============================================================================
// Probabilistic Sampling Configuration
// =============================================================================

// TraceSamplingConfig configures probabilistic sampling for traces.
//
// This configuration follows the OpenTelemetry probability sampling specification:
// https://opentelemetry.io/docs/specs/otel/trace/tracestate-probability-sampling/
//
// Implementations MUST follow tracestate standards to allow multi-stage sampling:
// https://opentelemetry.io/docs/specs/otel/trace/tracestate-handling/#sampling-threshold-value-th
//
// The sampling decision is based on comparing a 56-bit randomness value (R) against
// a rejection threshold (T). If R >= T, the span is kept; otherwise it is dropped.
// The threshold is derived from the configured percentage:
//   T = (1 - percentage/100) * 2^56
message TraceSamplingConfig {
  // Percentage at which items are sampled (0-100).
  // >= 100 samples all items, 0 rejects all items.
  // This is a 32-bit floating point value for precision.
  float percentage = 1;

  // Sampling mode determines how the sampling decision is made.
  // Optional. Default is SAMPLING_MODE_HASH_SEED.
  optional SamplingMode mode = 2;

  // Determines the number of hexadecimal digits used to encode the sampling threshold
  // in the tracestate. Permitted values are 1-14.
  // Optional. Default is 4.
  // Higher precision allows finer-grained sampling probabilities.
  // The threshold is encoded with trailing zeros removed.
  optional uint32 sampling_precision = 3;

  // An integer used to compute the hash algorithm.
  // All collectors for a given tier (e.g., behind the same load balancer)
  // should have the same hash_seed to ensure consistent sampling decisions.
  // Optional. Default is 0.
  optional uint32 hash_seed = 4;

  // Determines behavior when sampling errors occur.
  // When true (default), items with errors are rejected (fail closed).
  // When false, items with errors are accepted (fail open).
  // Optional. Default is true.
  optional bool fail_closed = 5;
}

// SamplingMode determines how the sampling decision is made.
enum SamplingMode {
  SAMPLING_MODE_UNSPECIFIED = 0;

  // hash_seed mode: Uses a hash of the trace ID combined with the hash_seed
  // to make deterministic sampling decisions. This is the default mode.
  // Suitable when you want consistent sampling across multiple collectors.
  SAMPLING_MODE_HASH_SEED = 1;

  // proportional mode: Respects existing sampling probability in tracestate.
  // Adjusts the effective probability to achieve the target percentage
  // relative to the incoming probability. For example, if incoming spans
  // are already sampled at 50% and target is 10%, this mode will sample
  // 20% of incoming spans to achieve 10% overall.
  SAMPLING_MODE_PROPORTIONAL = 2;

  // equalizing mode: Attempts to achieve the target percentage by preferentially
  // sampling spans that have been sampled at higher rates. This helps balance
  // the sampling across different sources while respecting existing thresholds.
  SAMPLING_MODE_EQUALIZING = 3;
}
