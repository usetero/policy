syntax = "proto3";

package tero.policy.v1;

import "tero/policy/v1/shared.proto";

option go_package = "github.com/usetero/policy/gen/go/tero/policy/v1";

// =============================================================================
// Metric Target
// =============================================================================

// MetricTarget defines matching and actions for metrics.
message MetricTarget {
  // Matchers to identify which metrics this policy applies to (AND logic)
  repeated MetricMatcher match = 1;

  // Whether to keep matching metrics (true) or drop them (false)
  bool keep = 2;
}

// =============================================================================
// Metric Field Selection
// =============================================================================

// MetricField identifies simple metric fields (non-keyed).
enum MetricField {
  METRIC_FIELD_UNSPECIFIED = 0;

  // Metric descriptor fields
  METRIC_FIELD_NAME = 1;
  METRIC_FIELD_DESCRIPTION = 2;
  METRIC_FIELD_UNIT = 3;

  // Schema URLs
  METRIC_FIELD_RESOURCE_SCHEMA_URL = 10;
  METRIC_FIELD_SCOPE_SCHEMA_URL = 11;

  // Scope fields (InstrumentationScope)
  METRIC_FIELD_SCOPE_NAME = 12;
  METRIC_FIELD_SCOPE_VERSION = 13;
}

// MetricType identifies the type of metric for matching.
enum MetricType {
  METRIC_TYPE_UNSPECIFIED = 0;
  METRIC_TYPE_GAUGE = 1;
  METRIC_TYPE_SUM = 2;
  METRIC_TYPE_HISTOGRAM = 3;
  METRIC_TYPE_EXPONENTIAL_HISTOGRAM = 4;
  METRIC_TYPE_SUMMARY = 5;
}

// AggregationTemporality defines how a metric aggregator reports aggregated values.
// Mirrors opentelemetry.proto.metrics.v1.AggregationTemporality.
enum AggregationTemporality {
  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
  AGGREGATION_TEMPORALITY_DELTA = 1;
  AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
}

// =============================================================================
// Metric Matching
// =============================================================================

// MetricMatcher provides a way to match against metric telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
// - Multiple matchers are ANDed together: all matchers must match for the
//   overall match to succeed.
// - The list of matchers should uniquely identify a specific pattern of telemetry
//   for that policy. Matchers should NOT be used as a catch-all; they should be
//   specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
message MetricMatcher {
  // FIELD SELECTION
  // The field to match against. Exactly one must be set.
  oneof field {
    // Simple fields (name, description, unit, etc.)
    MetricField metric_field = 1;

    // Data point attribute by key or path
    AttributePath datapoint_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;

    // Metric type matcher
    MetricType metric_type = 5;

    // Aggregation temporality matcher (applies to Sum, Histogram, ExponentialHistogram)
    AggregationTemporality aggregation_temporality = 6;
  }

  // Match type. Exactly one must be set.
  // Note: For metric_type field, only exists is valid (type equality is implicit).
  oneof match {
    // Exact string match
    string exact = 10;

    // Regular expression match
    string regex = 11;

    // Field existence check
    bool exists = 12;

    // Literal prefix match
    string starts_with = 13;

    // Literal suffix match
    string ends_with = 14;

    // Literal substring match
    string contains = 15;
  }

  // If true, inverts the match result
  bool negate = 20;

  // If true, applies case-insensitive matching to all match types
  bool case_insensitive = 21;
}
