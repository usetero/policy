syntax = "proto3";

package tero.policy.v1;

import "tero/policy/v1/shared.proto";

option go_package = "github.com/usetero/policy/gen/go/tero/policy/v1";

// =============================================================================
// Log Target
// =============================================================================

// LogTarget defines matching and actions for logs.
message LogTarget {
  // Matchers to identify which logs this policy applies to (AND logic)
  repeated LogMatcher match = 1;

  // The keep field controls whether matching telemetry survives. It unifies
  // dropping, sampling, and rate limiting into a single concept: what percentage
  // or amount of matching telemetry continues to the next stage?
  //
  // Valid values:
  //   "all"  - Keep everything (default, can be omitted)
  //   "none" - Drop everything
  //   "N%"   - Keep N percent (0-100), e.g. "50%"
  //   "N/s"  - Keep at most N per second, e.g. "100/s"
  //   "N/m"  - Keep at most N per minute, e.g. "1000/m"
  string keep = 2;

  // Transform operations to apply
  LogTransform transform = 3;

  // Field to use as the sampling key for consistent sampling.
  // When set, all logs with the same value for this field get the same
  // keep/drop decision. Use for lifecycle events (request_id, trace_id, job_id)
  // to avoid sampling individual log lines independently.
  //
  // Only applies when keep is a sampling value (N%, N/s, N/m).
  // Example: sample_key = log_attribute["request_id"] with keep = "10%" means
  // 10% of requests are kept, with all logs from each kept request preserved.
  LogSampleKey sample_key = 4;
}

// LogSampleKey specifies which field to use as the sampling key for consistent
// sampling decisions.
message LogSampleKey {
  // FIELD SELECTION (subset of LogMatcher fields appropriate for sampling keys)
  // The field to use as the sampling key. Exactly one must be set.
  oneof field {
    // Simple fields (trace_id, span_id, etc.)
    LogField log_field = 1;

    // Log record attribute by key or path
    AttributePath log_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;
  }
}

// =============================================================================
// Log Field Selection
// =============================================================================

// LogField identifies simple log fields (non-keyed).
enum LogField {
  LOG_FIELD_UNSPECIFIED = 0;

  // Log record fields
  LOG_FIELD_BODY = 1;
  LOG_FIELD_SEVERITY_TEXT = 2;
  LOG_FIELD_TRACE_ID = 3;
  LOG_FIELD_SPAN_ID = 4;
  LOG_FIELD_EVENT_NAME = 5;

  // Schema URLs
  LOG_FIELD_RESOURCE_SCHEMA_URL = 10;
  LOG_FIELD_SCOPE_SCHEMA_URL = 11;
}

// =============================================================================
// Log Matching
// =============================================================================

// LogMatcher provides a way to match against log telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
// - Multiple matchers are ANDed together: all matchers must match for the
//   overall match to succeed.
// - The list of matchers should uniquely identify a specific pattern of telemetry
//   for that policy. Matchers should NOT be used as a catch-all; they should be
//   specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
message LogMatcher {
  // FIELD SELECTION (keep in sync with LogRedact, LogRename, LogAdd, LogRemove)
  // The field to match against. Exactly one must be set.
  oneof field {
    // Simple fields (body, severity_text, trace_id, span_id, etc.)
    LogField log_field = 1;

    // Log record attribute by key or path
    AttributePath log_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;
  }

  // Match type. Exactly one must be set.
  oneof match {
    // Exact string match
    string exact = 10;

    // Regular expression match
    string regex = 11;

    // Field existence check
    bool exists = 12;

    // Literal prefix match
    string starts_with = 13;

    // Literal suffix match
    string ends_with = 14;

    // Literal substring match
    string contains = 15;
  }

  // If true, inverts the match result
  bool negate = 20;

  // If true, applies case-insensitive matching to all match types
  bool case_insensitive = 21;
}

// =============================================================================
// Log Transform
// =============================================================================

// LogTransform defines modifications to logs.
message LogTransform {
  // Fields to remove
  repeated LogRemove remove = 1;

  // Fields to redact
  repeated LogRedact redact = 2;

  // Fields to rename
  repeated LogRename rename = 3;

  // Fields to add
  repeated LogAdd add = 4;
}

// LogRemove removes a field.
message LogRemove {
  // FIELD SELECTION (keep in sync with LogMatcher, LogRedact, LogRename, LogAdd)
  // The field to remove. Exactly one must be set.
  oneof field {
    // Simple fields (body, severity_text, trace_id, span_id, etc.)
    LogField log_field = 1;

    // Log record attribute by key or path
    AttributePath log_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;
  }
}

// LogRedact masks a field value.
message LogRedact {
  // FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRename, LogAdd)
  // The field to redact. Exactly one must be set.
  oneof field {
    // Simple fields (body, severity_text, trace_id, span_id, etc.)
    LogField log_field = 1;

    // Log record attribute by key or path
    AttributePath log_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;
  }

  // Replacement value (e.g., "[REDACTED]")
  string replacement = 10;
}

// LogRename changes a field name.
message LogRename {
  // FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRedact, LogAdd)
  // The field to rename. Exactly one must be set.
  oneof from {
    // Simple fields (body, severity_text, trace_id, span_id, etc.)
    LogField from_log_field = 1;

    // Log record attribute by key or path
    AttributePath from_log_attribute = 2;

    // Resource attribute by key or path
    AttributePath from_resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath from_scope_attribute = 4;
  }

  // The new field name
  string to = 10;

  // If true, overwrites the target field if it already exists
  bool upsert = 11;
}

// LogAdd inserts a field.
message LogAdd {
  // FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRedact, LogRename)
  // The field to add. Exactly one must be set.
  oneof field {
    // Simple fields (body, severity_text, trace_id, span_id, etc.)
    LogField log_field = 1;

    // Log record attribute by key or path
    AttributePath log_attribute = 2;

    // Resource attribute by key or path
    AttributePath resource_attribute = 3;

    // Scope attribute by key or path
    AttributePath scope_attribute = 4;
  }

  // The value to set
  string value = 10;

  // If true, overwrites the field if it already exists
  bool upsert = 11;
}
